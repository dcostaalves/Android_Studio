Entity representa uma tabela no banco de dados. A Room cria uma tabela para cada classe que tem uma anotação @Entity e todos os campos dentro da classe correspondem a cada coluna. É a menor classe dentro do projeto

Dao é a classe onde definiremos os métodos para se conectar no banco de dados. Esse é o lugar onde escreveremos nossas queries

Database é a classe que armazena de fato nosso banco de dados e serve como acesso central para o acesso do nosso app.

1) criou um pacote DATA onde criou uma class USER
	-fez uma anotação @Entity(tableName = "user_table") //ela cria a base de dados, representa a tabela no banco de dados
	-dentro da class add uma anotação @PrimaryKey(autoGenerate= true), para dize q o "id" está sendo gerado automático
	
2) criou um UserDao dentro do pcte DATA
	-fez uma anotação @Dao sobre a interface UserDao{} //ela define os métodos, retorna pra comunicar com banco
	-Add uma @Insert(onConflict = OnConflictStrategy.IGNORE) + suspend fun addUser(user: User)
	-Add @Query("SELECT * FROM user_table ORDER BY id ASC") + fun lerTodosOsDados(): LiveData<List<User>>

3) criou uma nova class UserDataBase
	-fez anotação @Database(entities=[User::class], version = 1, exportSchema = false) //resp por guardar o banco de dados
	-fez uma abstract class UserDataBase{ abstract fun userDao(): UserDao
	companion object{ @Volatile + private var + fun getDatabase + synchronized + .build + INSTANCE = instance}
	}

4) criou uma class UserRepository() // ler os dados e fala como a função será executada
	-criou uma val lertodosdados
	-fez uma suspend fun para add usuario, p/ executar numa corrotina
	
5) criando uma class UserViewModel: ViewModel(){} //processa todos os dados da aplicação e executar os métodos por corrotina
	-faz uma val + private va
	-inicializa as variáveis c/ init{val userDao + repository + ler...}
	-criou fun addUser(){viewModelScope.lauch ...}

-room é grupo de bibliotecas que possui um tipo de banco de dados relacional